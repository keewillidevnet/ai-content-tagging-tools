/**
 * Usage Examples and Tests for Audio ID3 and Image EXIF/XMP Handlers
 * Demonstrates how to integrate the new multimedia metadata handlers
 */

const ID3AudioHandler = require('../../lib/formats/id3-audio');
const EXIFImageHandler = require('../../lib/formats/exif-image');
const { createMetadata, validateMetadata } = require('../../lib/core/metadata');
const fs = require('fs').promises;
const path = require('path');

/**
 * Example: Tag an audio file with AI content metadata
 */
async function tagAudioFile() {
  console.log('üéµ Tagging audio file with AI metadata...');
  
  try {
    // Create RFC-compliant metadata
    const metadata = createMetadata({
      contentType: 'audio',
      origin: 'ai-generated',
      model: 'MusicLM-2024',
      author: 'AI Music Studio',
      description: 'Jazz instrumental generated by AI',
      license: 'CC-BY-4.0',
      created: new Date().toISOString(),
      processingSteps: [
        {
          step: 'generation',
          tool: 'MusicLM',
          parameters: { style: 'jazz', duration: 180 }
        }
      ]
    });

    // Initialize audio handler
    const audioHandler = new ID3AudioHandler({
      version: '2.4',
      preserveExisting: true
    });

    // Create dummy audio data for demo
    const dummyAudioData = Buffer.alloc(1024); // 1KB dummy audio
    
    // Embed metadata with signature
    const taggedAudio = await audioHandler.embedMetadata(dummyAudioData, metadata, {
      includeChecksum: true,
      privateKey: process.env.PRIVATE_KEY // Optional signing
    });

    // Save tagged audio
    await fs.writeFile('./tagged-audio.mp3', taggedAudio);
    
    console.log('‚úÖ Audio file tagged successfully!');
    
    // Verify the tagging worked
    const extractedMetadata = await audioHandler.extractMetadata(taggedAudio);
    console.log('üìã Extracted metadata:', JSON.stringify(extractedMetadata, null, 2));
    
    return extractedMetadata;
  } catch (error) {
    console.error('‚ùå Error tagging audio:', error.message);
    throw error;
  }
}

/**
 * Example: Tag an image file with AI content metadata
 */
async function tagImageFile() {
  console.log('üñºÔ∏è Tagging image file with AI metadata...');
  
  try {
    // Create metadata for AI-generated image
    const metadata = createMetadata({
      contentType: 'image',
      origin: 'ai-generated',
      model: 'DALL-E-3',
      author: 'AI Art Generator',
      description: 'Surreal landscape with floating islands',
      license: 'Proprietary',
      created: new Date().toISOString(),
      prompt: 'A surreal landscape with floating islands, crystal clear water, and dramatic clouds',
      processingSteps: [
        {
          step: 'generation',
          tool: 'DALL-E-3',
          parameters: { 
            prompt: 'surreal landscape floating islands',
            style: 'photorealistic',
            resolution: '1024x1024'
          }
        }
      ]
    });

    // Initialize image handler
    const imageHandler = new EXIFImageHandler({
      preferredFormat: 'xmp', // Use XMP for better metadata support
      preserveExisting: true
    });

    // Create dummy JPEG data for demo
    const dummyImageData = Buffer.concat([
    Buffer.from([0xFF, 0xD8, 0xFF, 0xE0]), // JPEG SOI + APP0
    Buffer.alloc(1024), // 1KB dummy image data
    Buffer.from([0xFF, 0xD9]) // JPEG EOI
    ]);
   
    // Embed metadata
    const taggedImage = await imageHandler.embedMetadata(dummyImageData, metadata, {
      includeChecksum: true
    });

    // Save tagged image
    await fs.writeFile('./tagged-image.jpg', taggedImage);
    
    console.log('‚úÖ Image file tagged successfully!');
    
    // Verify the tagging worked
    const extractedMetadata = await imageHandler.extractMetadata(taggedImage);
    console.log('üìã Extracted metadata:', JSON.stringify(extractedMetadata, null, 2));
    
    return extractedMetadata;
  } catch (error) {
    console.error('‚ùå Error tagging image:', error.message);
    throw error;
  }
}

/**
 * Example: Batch processing multiple multimedia files
 */
async function batchProcessMultimedia() {
  console.log('üì¶ Batch processing multimedia files...');
  
  const audioHandler = new ID3AudioHandler();
  const imageHandler = new EXIFImageHandler();
  
  try {
    const inputDir = '../batch-input/';
    const outputDir = './batch-output/';
    
    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true });
    
    // Read all files in input directory
    const files = await fs.readdir(inputDir);
    
    for (const file of files) {
      const filePath = path.join(inputDir, file);
      const outputPath = path.join(outputDir, file);
      const fileExt = path.extname(file).toLowerCase();
      
      console.log(`Processing: ${file}`);
      
      try {
        let metadata, taggedFile, handler;
        
        // Determine file type and create appropriate metadata
        if (['.mp3', '.m4a', '.flac', '.wav'].includes(fileExt)) {
          // Audio file
          metadata = createMetadata({
            contentType: 'audio',
            origin: 'human-created',
            author: 'Unknown Artist',
            created: new Date().toISOString(),
            description: `Audio file: ${file}`
          });
          
          handler = audioHandler;
          taggedFile = await handler.embedMetadata(filePath, metadata);
          
        } else if (['.jpg', '.jpeg', '.png', '.tiff'].includes(fileExt)) {
          // Image file
          metadata = createMetadata({
            contentType: 'image',
            origin: 'human-created',
            author: 'Unknown Photographer',
            created: new Date().toISOString(),
            description: `Image file: ${file}`
          });
          
          handler = imageHandler;
          taggedFile = await handler.embedMetadata(filePath, metadata);
          
        } else {
          console.log(`‚è≠Ô∏è Skipping unsupported file: ${file}`);
          continue;
        }
        
        // Save tagged file
        await fs.writeFile(outputPath, taggedFile);
        console.log(`‚úÖ Tagged: ${file}`);
        
      } catch (fileError) {
        console.error(`‚ùå Error processing ${file}:`, fileError.message);
      }
    }
    
    console.log('üì¶ Batch processing completed!');
    
  } catch (error) {
    console.error('‚ùå Batch processing error:', error.message);
    throw error;
  }
}

/**
 * Example: Validate multimedia metadata integrity
 */
async function validateMultimediaMetadata() {
  console.log('üîç Validating multimedia metadata integrity...');
  
  const audioHandler = new ID3AudioHandler();
  const imageHandler = new EXIFImageHandler();
  
  const testFiles = [
    { path: './tagged-audio.mp3', type: 'audio' },
    { path: './tagged-image.jpg', type: 'image' }
  ];
  
  for (const testFile of testFiles) {
    try {
      console.log(`\nüìÅ Validating: ${testFile.path}`);
      
      const handler = testFile.type === 'audio' ? audioHandler : imageHandler;
      
      // Check if file has metadata
      const hasMetadata = await handler.hasMetadata(testFile.path);
      console.log(`Has metadata: ${hasMetadata ? '‚úÖ' : '‚ùå'}`);
      
      if (hasMetadata) {
        // Extract and validate metadata
        const metadata = await handler.extractMetadata(testFile.path);
        
        if (metadata) {
          console.log('üìã Metadata found:');
          console.log(`- Content Type: ${metadata.contentType}`);
          console.log(`- Origin: ${metadata.origin}`);
          console.log(`- Author: ${metadata.author || 'N/A'}`);
          console.log(`- Created: ${metadata.created}`);
          console.log(`- Checksum verified: ${metadata._verified ? '‚úÖ' : '‚ùå'}`);
          console.log(`- Signature valid: ${metadata._signatureValid ? '‚úÖ' : '‚ùå'}`);
          
          // Validate against RFC schema
          const isValidSchema = validateMetadata(metadata);
          console.log(`- Schema valid: ${isValidSchema ? '‚úÖ' : '‚ùå'}`);
          
        } else {
          console.log('‚ùå No AI metadata found');
        }
      }
      
    } catch (error) {
      console.error(`‚ùå Error validating ${testFile.path}:`, error.message);
    }
  }
}

/**
 * Example: Remove metadata from multimedia files
 */
async function removeMultimediaMetadata() {
  console.log('üóëÔ∏è Removing AI metadata from multimedia files...');
  
  const audioHandler = new ID3AudioHandler();
  const imageHandler = new EXIFImageHandler();
  
  const testFiles = [
    { path: './tagged-audio.mp3', output: './clean-audio.mp3', type: 'audio' },
    { path: './tagged-image.jpg', output: './clean-image.jpg', type: 'image' }
  ];
  
  for (const testFile of testFiles) {
    try {
      console.log(`\nüßπ Cleaning: ${testFile.path}`);
      
      const handler = testFile.type === 'audio' ? audioHandler : imageHandler;
      
      // Remove metadata
      const cleanFile = await handler.removeMetadata(testFile.path);
      
      // Save clean file
      await fs.writeFile(testFile.output, cleanFile);
      
      // Verify removal
      const hasMetadata = await handler.hasMetadata(cleanFile);
      console.log(`‚úÖ Cleaned file saved: ${testFile.output}`);
      console.log(`AI metadata removed: ${!hasMetadata ? '‚úÖ' : '‚ùå'}`);
      
    } catch (error) {
      console.error(`‚ùå Error cleaning ${testFile.path}:`, error.message);
    }
  }
}

/**
 * Example: Performance testing for multimedia handlers
 */
async function performanceTest() {
  console.log('‚ö° Running performance tests...');
  
  const audioHandler = new ID3AudioHandler();
  const imageHandler = new EXIFImageHandler();
  
  // Create test metadata
  const testMetadata = createMetadata({
    contentType: 'test',
    origin: 'performance-test',
    author: 'Test Suite',
    created: new Date().toISOString(),
    description: 'Performance test metadata'
  });
  
  // Test audio processing speed
  console.log('\nüéµ Audio Processing Performance:');
  const audioStart = Date.now();
  
  try {
    // Simulate multiple operations
    for (let i = 0; i < 10; i++) {
      const dummyAudio = Buffer.alloc(1024 * 1024); // 1MB dummy audio
      await audioHandler.embedMetadata(dummyAudio, testMetadata);
    }
    
    const audioTime = Date.now() - audioStart;
    console.log(`‚úÖ Processed 10 x 1MB audio files in ${audioTime}ms`);
    console.log(`‚ö° Average: ${audioTime / 10}ms per file`);
    
  } catch (error) {
    console.error('‚ùå Audio performance test failed:', error.message);
  }
  
  // Test image processing speed
  console.log('\nüñºÔ∏è Image Processing Performance:');
  const imageStart = Date.now();
  
  try {
    // Simulate multiple operations
    for (let i = 0; i < 10; i++) {
      // Create dummy JPEG header
      const dummyImage = Buffer.concat([
        Buffer.from([0xFF, 0xD8, 0xFF, 0xE0]), // JPEG SOI + APP0
        Buffer.alloc(1024 * 1024) // 1MB dummy image
      ]);
      await imageHandler.embedMetadata(dummyImage, testMetadata);
    }
    
    const imageTime = Date.now() - imageStart;
    console.log(`‚úÖ Processed 10 x 1MB image files in ${imageTime}ms`);
    console.log(`‚ö° Average: ${imageTime / 10}ms per file`);
    
  } catch (error) {
    console.error('‚ùå Image performance test failed:', error.message);
  }
}

/**
 * Example: Compare metadata formats
 */
async function compareMetadataFormats() {
  console.log('üîÑ Comparing metadata formats...');
  
  // Test XMP vs EXIF for images
  const imageHandler = new EXIFImageHandler();
  
  const testMetadata = createMetadata({
    contentType: 'image',
    origin: 'ai-generated',
    author: 'Format Test',
    created: new Date().toISOString(),
    description: 'Testing different metadata formats'
  });
  
  try {
    // Create dummy JPEG
    const dummyJPEG = Buffer.concat([
      Buffer.from([0xFF, 0xD8, 0xFF, 0xE0]), // JPEG SOI + APP0
      Buffer.from([0x00, 0x10]), // Length
      Buffer.from('JFIF\0\x01\x01\x01\x00H\x00H\x00\x00'), // JFIF header
      Buffer.from([0xFF, 0xD9]) // EOI
    ]);
    
    // Test XMP format
    console.log('\nüìù Testing XMP format:');
    imageHandler.options.preferredFormat = 'xmp';
    const xmpTagged = await imageHandler.embedMetadata(dummyJPEG, testMetadata);
    const xmpExtracted = await imageHandler.extractMetadata(xmpTagged);
    console.log(`XMP - Embedded: ${xmpTagged.length} bytes, Extracted: ${xmpExtracted ? '‚úÖ' : '‚ùå'}`);
    
    // Test EXIF format
    console.log('\nüìù Testing EXIF format:');
    imageHandler.options.preferredFormat = 'exif';
    const exifTagged = await imageHandler.embedMetadata(dummyJPEG, testMetadata);
    const exifExtracted = await imageHandler.extractMetadata(exifTagged);
    console.log(`EXIF - Embedded: ${exifTagged.length} bytes, Extracted: ${exifExtracted ? '‚úÖ' : '‚ùå'}`);
    
  } catch (error) {
    console.error('‚ùå Format comparison failed:', error.message);
  }
}

/**
 * Example: Error handling and edge cases
 */
async function testErrorHandling() {
  console.log('üõ°Ô∏è Testing error handling and edge cases...');
  
  const audioHandler = new ID3AudioHandler();
  const imageHandler = new EXIFImageHandler();
  
  // Test invalid metadata
  console.log('\n‚ùå Testing invalid metadata:');
  try {
    await audioHandler.embedMetadata(Buffer.alloc(100), { invalid: 'metadata' });
    console.log('‚ùå Should have thrown error for invalid metadata');
  } catch (error) {
    console.log('‚úÖ Correctly caught invalid metadata error');
  }
  
  // Test corrupted files
  console.log('\nüîß Testing corrupted files:');
  try {
    await imageHandler.extractMetadata(Buffer.from('not an image'));
    console.log('‚ùå Should have handled corrupted file');
  } catch (error) {
    console.log('‚úÖ Correctly handled corrupted file');
  }
  
  // Test empty files
  console.log('\nüìÑ Testing empty files:');
  try {
    const result = await audioHandler.hasMetadata(Buffer.alloc(0));
    console.log(`‚úÖ Empty file check: ${result ? 'has metadata' : 'no metadata'}`);
  } catch (error) {
    console.log('‚úÖ Correctly handled empty file');
  }
}

/**
 * Main demo function
 */
async function runDemo() {
  console.log('üöÄ AI Content Tagging Tools - Multimedia Support Demo\n');
  console.log('=' * 60);
  
  try {
    // Run all examples
    await tagAudioFile();
    console.log('\n' + '='.repeat(50) + '\n');
    
    await tagImageFile();
    console.log('\n' + '='.repeat(50) + '\n');
    
    await validateMultimediaMetadata();
    console.log('\n' + '='.repeat(50) + '\n');
    
    await batchProcessMultimedia();
    console.log('\n' + '='.repeat(50) + '\n');
    
    await removeMultimediaMetadata();
    console.log('\n' + '='.repeat(50) + '\n');
    
    await performanceTest();
    console.log('\n' + '='.repeat(50) + '\n');
    
    await compareMetadataFormats();
    console.log('\n' + '='.repeat(50) + '\n');
    
    await testErrorHandling();
    console.log('\n' + '='.repeat(50) + '\n');
    
    console.log('üéâ All multimedia demos completed successfully!');
    
    console.log('\nüìö Integration complete! Your repository now supports:');
    console.log('- ‚úÖ Audio ID3 Tags (MP3, M4A, FLAC, WAV)');
    console.log('- ‚úÖ Image EXIF/XMP (JPEG, with TIFF/PNG planned)');
    console.log('- ‚úÖ RFC-compliant metadata embedding');
    console.log('- ‚úÖ Cryptographic verification');
    console.log('- ‚úÖ Batch processing capabilities');
    console.log('- ‚úÖ Performance optimizations');
    
  } catch (error) {
    console.error('üí• Demo failed:', error.message);
    process.exit(1);
  }
}

/**
 * Individual test functions for specific scenarios
 */
async function testAudioFormats() {
  console.log('üéµ Testing different audio format support...');
  
  const handler = new ID3AudioHandler();
  const metadata = createMetadata({
    contentType: 'audio',
    origin: 'test',
    created: new Date().toISOString()
  });
  
  // Test different "audio" files (simulated)
  const formats = ['.mp3', '.m4a', '.flac', '.wav'];
  
  for (const format of formats) {
    try {
      console.log(`Testing ${format} format support...`);
      // In a real scenario, you'd load actual files
      const dummyAudio = Buffer.alloc(1024);
      const result = await handler.embedMetadata(dummyAudio, metadata);
      console.log(`‚úÖ ${format}: ${result.length} bytes processed`);
    } catch (error) {
      console.error(`‚ùå ${format}: ${error.message}`);
    }
  }
}

async function testImageFormats() {
  console.log('üñºÔ∏è Testing different image format detection...');
  
  const handler = new EXIFImageHandler();
  
  // Test format detection
  const jpegHeader = Buffer.from([0xFF, 0xD8, 0xFF]);
  const pngHeader = Buffer.from([0x89, 0x50, 0x4E, 0x47]);
  const tiffHeader = Buffer.from([0x49, 0x49]);
  
  console.log(`JPEG detected: ${handler._detectImageFormat(jpegHeader)}`);
  console.log(`PNG detected: ${handler._detectImageFormat(pngHeader)}`);
  console.log(`TIFF detected: ${handler._detectImageFormat(tiffHeader)}`);
}

// Export functions for testing and integration
module.exports = {
  tagAudioFile,
  tagImageFile,
  batchProcessMultimedia,
  validateMultimediaMetadata,
  removeMultimediaMetadata,
  performanceTest,
  compareMetadataFormats,
  testErrorHandling,
  testAudioFormats,
  testImageFormats,
  runDemo
};

// Run demo if called directly
if (require.main === module) {
  runDemo().catch(console.error);
}
